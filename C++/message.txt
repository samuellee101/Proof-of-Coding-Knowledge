#ifndef AUTOCOMPLETER_H
#define AUTOCOMPLETER_H

#include <vector>
#include <string>
#include <cassert>
#include <fstream>

using namespace std;

class Autocompleter
{
	// For the mandatory running times below:
	// n is the number of strings in the dictionary.
	// h is the current height of the tree.
	// Assume that the length of every string is O(1).

public:
	// Creates a dictionary of strings and associated frequencies,
	// using the file as a source. The file is promised to have
	// the following format:
	//
	// string1 freq1
	// string2 freq2
	// ...
	// stringN freqN
	//
	// where string1 < string2 < ... < stringN
	//
	// Must run in O(n) time.
	Autocompleter(string filename)
	{
		Entry newLocal;					// 
		ifstream inFile;
		string line;
		inFile.open(filename);
		while (!inFile.eof())				// Gets all the lines from a file
		{
			inFile >> newLocal.s >> newLocal.freq;		// Pushes the recorded information in H
			//int size = H.size() - 1;
			//if (size < 0|| newLocal.s != H[size].s)
			H.push_back(newLocal);
		}
		inFile.close();
		int begin = 0;
		int end = H.size() - 1;
		root = buildTree(H, begin, end);
	};

	// Returns the number of strings in the dictionary
	// of possible completions.
	//
	// Must run in O(1) time.
	int size()
	{
		return H.size();
	};

	// Fills the vector T with the three most-frequent completions of x.
	// If x has less than three completions,
	// then T is filled with all completions of x.
	// The completions appear in T from most- to least-frequent.
	//
	// Must run in O( hk ) time in general,
	// and O( klog(n) ) time if 'insert' or 'remove' have
	// never been called.  Here k denotes the number of completions
	// of x in the dictionary.  If k=0, the run time should be O(h) and O(log n) respectively.
	void completions(string x, vector<string>& T)
	{
		vector<Entry> top_3;
		vector<string> top;
		completions_recurse(x, root, top_3);
		// if the list has 3 items
		//if (top_3.size() == 3)
		//{
		//	top.push_back(top_3[0].s);
		//	top.push_back(top_3[1].s);
		//	top.push_back(top_3[2].s);
		//}
		//// if the list has 2 items
		//else if (top_3.size() == 2)
		//{
		//	top.push_back(top_3[0].s);
		//	top.push_back(top_3[1].s);
		//	
		//}
		//// if the list has 1 item
		//else if(top_3.size() == 1)
		//{
		//	top.push_back(top_3[0].s);
		//}
		for (int i = 0; i < top_3.size(); ++i)
		{
			top.push_back(top_3[i].s);
		}
		T = top;
	};

	// Add x to the autocompleter with frequency f.  Must run in O(h) time.
	void insert(string x, int f)
	{
		recInsert(f, x, root);
	};

	// Remove x from the autocompleter.  Must run in O(h) time.
	void remove(string x)
	{
		recRemove(x, root);
	};

private:

	// A helper class that stores a string and a frequency.
	class Entry
	{
	public:
		string s;
		int freq;
	};

	// A helper class that implements a BST node.
	class Node
	{
	public:
		Node()
		{
			left = right = nullptr;
		}

		Node(Entry e)
		{
			this->e = e;
			left = right = nullptr;
		}

		Entry e;
		Node* left;
		Node* right;
	};

	// Root of the binary-search-tree-based data structure
	Node* root;
	vector<Entry> H;
	//vector<string> top_3;
	//You will likely need to add some additional variables
	//and helper methods to private.  One suggested helper
	//method prototype (completions_recurse) is provided to help you out.


	//A suggested helper function:
	// Fills T with the three most-frequent completions of x
	// that are either:
	// -In the BST rooted at root.
	// -Already in T.
	//
	// Should run in O(h + k) time, where
	// -h is the height of the BST rooted at p.
	// -k is the number of Entrys in the BST rooted at p
	//  whose strings start with x.
	void completions_recurse(string x, Node* p, vector<Entry>& T)
	{
		// Once it reaches a null pointer
		if (p == nullptr)
			return;
		// Store the node's word
		string temp = p->e.s;
		// Size of the user input
		int size = x.size();
		// Will reduce the node's word to check if it's right
		temp = temp.substr(0, size);
		// Will compare once they have the same size
		if (x == temp)
		{
			// Will push the current node into the list
			T.push_back(p->e);
			// List is bigger than 3
			if (T.size() > 3 )
			{
				// Will hold the last value
				Entry Helper = T[3];
				// If the newest item is bigger than the 1st item on the list
				if (T[0].freq < T[3].freq)
				{
					biggest(T[3], T);
					T.pop_back();
				}
				// If the newest item is bigger than the 2nd item
				else if (T[1].freq < T[3].freq)
				{
					medium(T[3], T);
					T.pop_back();
				}
				// if the newest item is bigger than the 3rd
				else if (T[2].freq < T[3].freq)
				{
					smallest(T[3], T);
					T.pop_back();
				}
				// If all the items are bigger then the newest item
				else
					T.pop_back();
			}
			// Less than 3 items on the list 
			else
			{
				// When the size is less than 3 and bigger than 1
				if (T.size() > 1)
				{
					// When the size is only 2 
					if (T.size() == 2)
					{
						if (T[0].freq < T[1].freq)
						{
							biggest(T[1], T);
						}
					}
					// when the size is 3
					else
					{
						// Variable that stores the latest item
						Entry Help = T[2];
						// Checks if the 1st item is lower than the newest value
						if (T[0].freq < T[2].freq)
						{
							biggest(T[2], T);
						}
						// Checks if the 2nd item is lower than the newest item
						else if(T[1].freq < T[2].freq)
						{
							medium(T[2], T);
						}

					}
				}
			}
			// Keeps recursing on the left side
			completions_recurse(x, p->left, T);
			// Keeps recursing on the right side
			completions_recurse(x, p->right, T);
			
		}
		else if (x < temp)
		{
			completions_recurse(x, p->left, T);
		}
		else if (x > temp)
		{
			completions_recurse(x, p->right, T);
		}
	};

	// Function for the biggest item
	void biggest(Entry x, vector<Entry>& T)
	{
		// Changes the biggest item vector item when there is more than 3 items
		if (T.size() > 3)
		{
			// Reassigns the values without loosing any of them
			T[3] = T[2];
			T[2] = T[1];
			T[1] = T[0];
			T[0] = x;
		}
		// Changes the biggest vector item when there is 2 items
		else if (T.size() == 2)
		{
			// Reassigns the values without loosing any of them
			T[1] = T[0];
			T[0] = x;
		}
		// Changes the biggest vector item when there is 3 items
		else
		{
			// Reassigns the values without loosing any of them
			T[2] = T[1];
			T[1] = T[0];
			T[0] = x;
		}
	}

	// Function for the middle item
	void medium(Entry x, vector<Entry>& T)
	{
		// Changes the medium value if there are more than 3 items
		if (T.size() > 3)
		{
			// Reassigns them without lossing any of the data
			T[3] = T[2];
			T[2] = T[1];
			T[1] = x;
		}
		// Changes the medium value if there are 3 items
		else
		{
			// Reassigns them without lossing any of the data
			T[2] = T[1];
			T[1] = x;
		}
	}

	// Function for the smallest item
	void smallest(Entry x, vector<Entry>& T)
	{
		// Reassigns them without lossing any of the data
		T[3] = T[2];
		T[2] = x;
	}

	//Insert value x into the subtree rooted
		//at node p.
		//run time: O(h), where h is height of tree
	void recInsert(int x, string word, Node*& p)
	{
		//base case:
		Entry helper;
		helper.s = word;
		helper.freq = x;
		if (p == nullptr)
		{
			p = new Node(helper);
		}
		// if the item is already there so we will increase the frequency by how many times the user has specified 
		else if (p->e.s == word)
		{
			// Number of times used
			int times = p->e.freq;
			// Will add the previous item plus how many items it has been writen
			times = times + helper.freq;
			// Will assign the value
			p->e.freq = times;
			// Will return since the item is already there
			return;
		}
		
		else //recursive case
		{
			// if the word is lower than the p word
			if (word < p->e.s)
			{
				
				recInsert(x, word, p->left);
			}
			// if the word is bigger than the p word
			else
			{
				recInsert(x, word, p->right);
			}
		}
	}
	//Remove x from tree rooted at p.
	//run time: O(h), h is height of tree.
	void recRemove(string x, Node*& p)
	{
		if (p == nullptr)
		{
			//empty tree, x not present, do nothing
		}
		else if (x == p->e.s)
		{
			//Found x, must get rid of it.....
			if (p->left == nullptr && p->right == nullptr)  //p has no children
			{
				delete p;
				p = nullptr;
			}
			else if (p->right == nullptr) //p has 1 left child
			{
				Node* doomednode = p;
				p = p->left;
				delete doomednode;
			}
			else if (p->left == nullptr) //p has 1 right child
			{
				Node* doomednode = p;
				p = p->right;
				delete doomednode;
			}
			else //2 children..... oh no!  This is super hard
			{
				p->e.s = extractMin(p->right);
			}
		}
		else if (x < p->e.s)
		{
			recRemove(x, p->left);
		}
		else
		{
			recRemove(x, p->right);
		}
	}
	// Will extract the min 
	string extractMin(Node*& p)
	{
		//Checks if the pointer that has the smallest value is not empty
		if (p->left != nullptr)
			return extractMin(p->left);
		// if the next node is empty will get the data and delete the node
		else
		{
			// if the node is a leaf
			if (p->right == nullptr)
			{
				// Get value of such leaf
				string data = p->e.s;
				delete p;
				p = nullptr;
				return data;
				// Returns the data
			}
			// If the pointer has a right node
			else if (p->right != nullptr)
			{
				Node* temp = p;
				// Creates a temporary node
				string data = temp->e.s;
				// Then stores that data into
				// Points to the next node
				p = p->right;
				delete temp;
				return data;
				// Returns the data
			}
		}
	}

	// Helper function that builds the three
	Node* buildTree(vector<Entry>& A, int start, int end)
	{
		// Stores the middle point of the vector
		int mid = (start + end) / 2;
		// Stores the value of that part of the vector
		Entry mid_value = A[mid];
		// Will put the value that is inside the array into a new node
		Node* seed = new Node(mid_value);
		// Once the start is bigger than the end will return null pointer
		if (start > end)
			return nullptr;

		// Will start building the left side of the tree
		Node* root_left = buildTree(A, start, (mid - 1));
		// Will start building the right side of the tree
		Node* root_right = buildTree(A, (mid + 1), end);

		// Will connect the left side of the tree 
		seed->left = root_left;	// Into the left side of the root

		// Will connect the right side of the tree
		seed->right = root_right;	// Into the right of the root 

		// Will return the connected tree
		return seed;
	};
};